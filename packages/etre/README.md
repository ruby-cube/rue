<nav><a id="readme-top" href="#"><b>goto: src</b></a></nav>

[@rue](https://github.com/ruby-cube/rue#readme-top)  &nbsp;&nbsp;|&nbsp; &nbsp;  **etre**  &nbsp;&nbsp;|&nbsp; &nbsp; modos
# √ätre ü™¥

<aside>
‚ö†Ô∏è <b>Experimental:</b> √ätre is a work-in-progress, not well-tested, with a volatile API. Look and play, but definitely don‚Äôt use‚Ä¶
</aside>

<p align="right"><a href="#">[src]</a></p>

## Overview

Prefer composition over inheritance, they say. How about both? √ätre is an exploration into creating a system of composition that retains elements of inheritance.

<p align="right"><a href="#">[src]</a></p>

## Installation

```bash
(coming soon ...)
```
<p align="right"><a href="#">[src]</a></p>

## Table of Contents

- [Concepts](#concepts-roles--prereqs)
- [√ätre API](#%C3%AAtre-api)
- [Basic Usage](#basic-usage)
- [Non-redundant Inheritance](#non-redundant-inheritance)
- [Auto-compose vs Manual Compose](#auto-compose-vs-manual-compose)
- [Typescript hints and the `__dev__` parameter](#typescript-hints-and-the-__dev__-parameter)
- [Rekey-ing](#rekey-ing)
- [Interfaces](#interfaces)
- [Type-checking](#type-checking)
<p align="right"><a href="#readme-top">[top]</a></p>

## Concepts: Roles & Prereqs

In this system, composition and inheritance is achieved through the concepts of roles and prereqs. A role can have other roles as prereqs. The instantiated role will possess all the properties and methods of the role as well as all the properties and methods of its prereqs and its prereqs‚Äô prereqs‚Ä¶ all the way up the lines of inheritance.

This differs from traditional inheritance in that a role can have many prereqs whereas a class can extend only one other class. It differs from traditional composition through dependency injection in that prereqs cannot be redundant. With dependency injection, if a class A is composed of class B and C, which both inherit class D, class D‚Äôs constructor will run twice in order to instantiate class A. In the √ätre system, prereqs are collected into a set at the time of creating the instantiator function, ensuring non-redundancy.

The instantiator function is obtained by calling the `reifier` method of a role.

The system also allows for re-keying (in case of key collisions) and implementing interfaces.

<p align="right"><a href="#table-of-contents">[toc]</a></p>

## √ätre API
[`role(config)`](#basic-usage)

[`enacts(Role, object)`](#type-checking)

[`keyCollisionCheck(Role, true, RekeyMap)`](#rekey-ing)

[`roleCollisionCheck(Role)`](#rekey-ing)

<p align="right"><a href="#table-of-contents">[toc]</a></p>

## Basic Usage

`role` takes in a config object that resembles a class definition, with a `$construct` function and methods. (credit: Code examples make references to Jim Henson's *The Frog Prince* (1971))

```js
// role A
export const Frog = role({
    $construct(data) {
        return {
            location: data.location
        }
    },
    croak() { /* ... */ }
});
```

```js
// role B
export const Prince = role({
    $construct(data) {
        return {
            mountainOfTalent: data.mountainOfTalent
        }
    },
    isValiantAndDaring() { /* ... */ },
    isNobleOfBearing() { /* ... */ },
    isCourageousAndGallant() { /* ... */ },
});
```

```js
// role C (composed of role A and role B)
export const FrogPrince = role({
    prereqs: {
        Frog,
        Prince
    },
    $construct(data) {
        return {
            name: data.name
        }
    },
    sing() { /* ... */ }
}

// instantiator function (generated by invoking `reifier` method)
export const createFrogPrince = FrogPrince.reifier();
```

```js
// instantiation
const frogPrince = createFrogPrince({
    name: "Sir Robin the Brave",
    location: "wishing well",
    mountainOfTalent: ["singing", "sword fights"]
})

// method calls & property access
frogPrince.croak(); // "ribbit"
frogPrince.isValiantAndDaring(); // true
frogPrince.sing();
frogPrince.name; // "Sir Robin the Brave"
```
<p align="right"><a href="#table-of-contents">[toc]</a></p>

## Non-redundant Inheritance

When implementing composition via Javascript classes, you may end up with a situation where the constructor of an inherited class runs redundantly.

```js
class Character {
    constructor() {
        console.log("setup")
    }
}

class Frog extends Character {
    constructor() {
        super()
    }
}

class Prince extends Character {
    constructor() {
        super()
    }
}

class FrogPrince {
    constructor(frog, prince) {
        // ...
    }
}

const sirRobin = new FrogPrince(new Frog(), new Prince()) // logs "setup" twice
```

With role creation, `prereqs` are gathered into a set and each prereq is run once only.

```js
const Character = role({
    $construct(){
        console.log("setup")
    }
})

const Frog = role({
    prereqs: { Character },
})

const Prince = role({
    prereqs: { Character },
})

const FrogPrince = role({
    prereqs: { Frog, Prince },
})

const createFrogPrince = FrogPrince.reifier();

const sirRobin = createFrogPrince(); // logs "setup" once
```
<p align="right"><a href="#table-of-contents">[toc]</a></p>

## Auto-compose vs Manual Compose

In the examples above, the `reifier` method generates a function that will auto-compose the different roles into one object. However, in cases where roles interact with each other during construction, you will need to pass a manual compose function into the `reifier`:

```js
const Character = role({
    $construct(data){
        return {
            name: format(data.name)
        }
    }
})

const Frog = role({
    prereqs: { Character },
    croak() { }
})

const Prince = role({
    prereqs: { Character },
    $construct(data, formattedName) { // requires formatted name from $Character
        return {
            honorific: formattedName + " " + data.epithet
        }
    },
    fight() { }
})

const FrogPrince = role({
    prereqs: { Frog, Prince },
    sing() { }
})

// manual compose
const createFrogPrince = FrogPrince.reifier((data) => {
    const { props: { name } } = Character.confer(data);
    const { methods: { croak } } = Frog.confer();
    const { props: { honorific }, methods: { fight } } = Prince.confer(data, name);
    const { methods: { sing } } = FrogPrince.confer();

    return {
        name,
        honorific,
        croak,
        fight,
        sing
    }
});

const sirRobin = createFrogPrince(data);
```

The `confer` method of an abstract role returns an object with two properties: `props` and `methods`. These can be deconstructed, as in the example above, or spread, as in the example below:

```js
// manual compose
const createFrogPrince = FrogPrince.reifier((data) => {
    const character = Character.confer(data);
    const frog = Frog.confer();
    const prince = Prince.confer(data, character.props.name);
    const frogPrince = FrogPrince.confer();

    return {
        ...character.props,
        ...frog.methods,
        ...prince.props,
        ...prince.methods,
        ...frogPrince.methods
    }
});

const sirRobin = createFrogPrince(data);
```
<p align="right"><a href="#table-of-contents">[toc]</a></p>

## Typescript hints and the `__dev__` parameter

When manually composing a data model, you may not always know what prereqs are needed or whether a prop or method is missing. Fortunately, Typescript will indicate missing props and methods with TS errors.

The `reifier` method also takes in a `__dev__` argument for development purposes. The `__dev__` parameter requires an object with the property `__prereqs__` that contains all the prereqs down all inheritance lines. Typescript will show an error if any roles are missing. In this way, you can easily obtain a list of what prereqs are required to create the object. In VSCode, simply *control+space* within the object brackets to see what prereqs are missing.

```js
// Typescript error will indicate missing properties/methods
const createFrogPrince = FrogPrince.reifier((data) => {
    const frog = Frog.confer();
    return {
        ...frog.methods, 
    }
}, {
    __prereqs__: { 
        Frog,
        Prince
        // VSCode: control+space for intellisense to show other required roles: Character
    }
});
```
<p align="right"><a href="#table-of-contents">[toc]</a></p>

## Rekey-ing

If working on a larger project, developers may encounter name collisions of properties or methods of roles being composed together. During development, √ätre will warn of name collisions when auto-composing objects.

When manually composing, √ätre provides two collision check functions: `keyCollisionCheck` and `roleCollisionCheck`.  Note that role collisions aren‚Äôt a problem in itself, but it‚Äôs useful to know of role collisions when rekeying. *[todo: expound upon this]*

To rekey a prop or method, add a `__rekey__` prop to the second argument. The `__rekey__` prop is a rekey map that lets Typescript know what props and methods are being renamed to what.

```ts
const createFrogPrince = FrogPrince.reifier((data) => {
    const { props: { voice: froggyVoice } } = Frog.confer();
    const { props: { voice } } = Prince.confer()
    return {
        voice,
        froggyVoice
    };
}, {
    __prereqs__: {
        Frog,
        Prince
    },
    __rekey__: $type as RekeyMap
})

    
type RekeyMap = {
    Frog: { voice: "frogVoice" }
}

  
if (__DEV__){ 
    // Typescript errors indicate collision
    keyCollisionCheck(FrogPrince, true, $type as RekeyMap); 
    roleCollisionCheck(FrogPrince);
}
```
<p align="right"><a href="#table-of-contents">[toc]</a></p>

## Interfaces

When defining a role, the config‚Äôs interface property defines an interface that must be implemented either by one of the roles that inherits that role or by the manual compose function.

```ts
type ICharacter = {
    talk: () => void
}

const Character = role({
    interface: $type as ICharacter,
    $construct(){
        // character setup
    },
    exist(){ /* ... */ }
})

const Frog = role({
    implements: $type as ICharacter,
    prereqs: {
        Character
    },
    talk() {
        console.log("ribbit")        
    }
})
```
<p align="right"><a href="#table-of-contents">[toc]</a></p>

## Type-checking

Objects can be type-checked via the `enacts` function, which takes in a role as the first argument and the object being type-checked as the second argument and returns a boolean.

```js
const isFrog = enacts(character, Frog);
```

<p align="right"><a href="#readme-top">[top]</a></p>

¬© 2023 - present [Ruby Y Wang](https://github.com/ruby-cube)

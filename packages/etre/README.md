[@rue](https://github.com/ruby-cube/rue)  &nbsp;&nbsp;|&nbsp; &nbsp;  etre  &nbsp;&nbsp;|&nbsp; &nbsp; modos
# √ätre ü™¥

<aside>
‚ö†Ô∏è Experimental: √ätre is a work-in-progress, not well-tested, with a volatile API. Look and play, but definitely don‚Äôt use‚Ä¶
</aside>
</br>
</br>

## Overview

Composition over inheritance, they say. How about both? √ätre is an exploration into creating a system of composition that retains elements of inheritance.

</br>

## Installation

```bash
(coming soon ...)
```
</br>

## Table of Contents

- Concepts
- Basic Usage
- Non-redundant Inheritance
- Auto-compose vs Manual Compose
- Typescript hints and the `__dev__` parameter
- Rekey-ing
- Interfaces
- Type-checking
</br>

## Concepts: Abstract Roles & Prereqs

In this system, composition and inheritance is achieved through the concepts of abstract roles and prereqs. An abstract role can be defined as having prereqs, which are other abstract roles. An abstract role can then be instantiated through a function generated by the role‚Äôs `reifier` method. The instantiated object will contain all the properties and methods of the abstract role as well as all the properties and methods of its prereqs and its prereqs‚Äô prereqs‚Ä¶ all the way up the lines of inheritance.

This differs from traditional inheritance in that a role can have many prereqs whereas a class can extend only one other class, and it differs from composition through dependency injection in that prereqs cannot be redundant. With dependency injection, if a class A is composed of class B and C, which both inherit class D, class D‚Äôs constructor will run twice in order to instantiate class A. In the Etre system, prereqs are collected into a set at the time of creating the reifier function, ensuring non-redudancy. 

The system also allows for re-keying in the event of name collisions and implementing interfaces.

</br>

## Basic Usage

`defineRole` takes in a config object that resembles a class definition, with a `$construct` function and methods.

```jsx
// abstract role A
export const $Frog = defineRole({
    $construct(data) {
        return {
            location: data.location
        }
    },
    croak() { /* ... */ }
});
```

```jsx
// abstract role B
export const $Prince = defineRole({
    $construct(data) {
        return {
            mountainOfTalent: data.mountainOfTalent
        }
    },
    isValiantAndDaring() { /* ... */ },
    isNobleOfBearing() { /* ... */ },
    isCourageousAndGallant() { /* ... */ },
});
```

```jsx
// abstract role C (composed of role A and role B)
export const $FrogPrince = defineRole({
    prereqs: {
        $Frog,
        $Prince
    },
    $construct(data) {
        return {
            name: data.name
        }
    },
    sing() { /* ... */ }
}

// instantiator function (generated by invoking `reifier` method)
export const createFrogPrince = $FrogPrince.reifier();
```

```jsx
// instantiation
const frogPrince = createFrogPrince({
    name: "Sir Robin the Brave",
    location: "wishing well",
    mountainOfTalent: ["singing", "sword fights"]
})

// method calls & property access
frogPrince.croak(); // "ribbit"
frogPrince.isValiantAndDaring(); // true
frogPrince.sing();
frogPrince.name; // "Sir Robin the Brave"
```
</br>

## Non-redundant Inheritance

When implementing composition via Javascript classes, you may end up with a situation where the constructor of an inherited class runs redundantly.

```jsx
class Character {
    constructor() {
        console.log("setup")
    }
}

class Frog extends Character {
    constructor() {
        super()
    }
}

class Prince extends Character {
    constructor() {
        super()
    }
}

class FrogPrince {
    constructor(frog, prince) {
        // ...
    }
}

const sirRobin = new FrogPrince(new Frog(), new Prince()) // logs "setup" twice
```

With role creation, `prereqs` are gathered into a set and each prereq is run once only.

```jsx
const $Character = defineRole({
    $construct(){
        console.log("setup")
    }
})

const $Frog = defineRole({
    prereqs: { $Character },
})

const $Prince = defineRole({
    prereqs: { $Character },
})

const $FrogPrince = defineRole({
    prereqs: { $Frog, $Prince },
})

const createFrogPrince = $FrogPrince.reifier();

const sirRobin = createFrogPrince(); // logs "setup" once
```
</br>

## Auto-compose vs Manual Compose

In the examples above, the `reifier` method generates a function that will auto-compose the different roles into one object. However, in cases where roles interact with each other during construction, you will need to pass a manual compose function into the `reifier`:

```jsx
const $Character = defineRole({
    $construct(data){
        return {
            name: format(data.name)
        }
    }
})

const $Frog = defineRole({
    prereqs: { $Character },
    croak() { }
})

const $Prince = defineRole({
    prereqs: { $Character },
    $construct(data, formattedName) { // requires formatted name from $Character
        return {
            honorific: formattedName + " " + data.epithet
        }
    },
    fight() { }
})

const $FrogPrince = defineRole({
    prereqs: { $Frog, $Prince },
    sing() { }
})

// manual compose
const createFrogPrince = $FrogPrince.reifier((data) => {
    const { props: { name } } = $Character.confer(data);
    const { methods: { croak } } = $Frog.confer();
    const { props: { honorific }, methods: { fight } } = $Prince.confer(data, name);
    const { methods: { sing } } = $FrogPrince.confer();

    return {
        name,
        honorific,
        croak,
        fight,
        sing
    }
});

const sirRobin = createFrogPrince(data);
```

The `confer` method of an abstract role returns an object with two properties: `props` and `methods`. These can be deconstructed, as in the example above, or spread, as in the example below:

```jsx
// manual compose
const createFrogPrince = $FrogPrince.reifier((data) => {
    const character = $Character.confer(data);
    const frog = $Frog.confer();
    const prince = $Prince.confer(data, character.props.name);
    const frogPrince = $FrogPrince.confer();

    return {
        ...character.props,
        ...frog.methods,
        ...prince.props,
        ...prince.methods,
        ...frogPrince.methods
    }
});

const sirRobin = createFrogPrince(data);
```
</br>

## Typescript hints and the `__dev__` parameter

When manually composing a data model, you may not always know what prereqs are needed or whether a prop or method is missing. Fortunately, Typescript will indicate missing props and methods with TS errors.

The `reifier` method also takes in a `__dev__` argument for development purposes. The `__dev__` parameter requires an object with the property `__prereqs__` that contains all the prereqs down all inheritance lines. Typescript will show an error if any roles are missing. In this way, you can easily obtain a list of what prereqs are required to create the object. In VSCode, simply *control+space* within the object brackets to see what prereqs are missing.

```jsx
// Typescript error will indicate missing properties/methods
const createFrogPrince = $FrogPrince.reifier((data) => {
    const frog = $Frog.confer();
    return {
        ...frog.methods, 
    }
}, {
    __prereqs__: { 
        $Frog,
        $Prince
        // VSCode: control+space for intellisense to show other required roles: $Character
    }
});
```
</br>

## Rekey-ing

If working on a larger project, developers may encounter name collisions of properties or methods of roles being composed together. During development, Etre will warn of name collisions when auto-composing objects.

When manually composing, Etre provides two collision check functions: `keyCollisionCheck` and `roleCollisionCheck`.  Note that role collisions aren‚Äôt a problem in itself, but it‚Äôs useful to know of role collisions when rekeying. *[todo: expound upon this]*

To rekey a prop or method, add a `__rekey__` prop to the second argument. The `__rekey__` prop is a rekey map that lets Typescript know what props and methods are being renamed to what.

```tsx
const createFrogPrince = $FrogPrince.reifier((data) => {
    const { props: { voice: froggyVoice } } = $Frog.confer();
    const { props: { voice } } = $Prince.confer()
    return {
        voice,
        froggyVoice
    };
}, {
    __prereqs__: {
        $Frog,
        $Prince
    },
    __rekey__: $type as RekeyMap
})

    
type RekeyMap = {
    $Frog: { voice: "frogVoice" }
}

  
if (__DEV__){ 
    // Typescript errors indicate collision
    keyCollisionCheck($FrogPrince, true, $type as RekeyMap); 
    roleCollisionCheck($FrogPrince);
}
```
</br>

## Interfaces

When defining a role, the config‚Äôs interface property defines an interface that any must be implemented either by one of the roles that inherits that role or by the manual compose function.

```tsx
type ICharacter = {
    talk: () => void
}

const $Character = defineRole({
    interface: $type as ICharacter
})

const $Frog = defineRole({
    implements: $type as ICharacter,
    talk() {
        console.log("ribbit")        
    }
})
```
</br>

## Type-checking

Objects can be type-checked via the `enacts` function, which takes in an abstract role as the first argument and the object being type-checked as the second argument and returns a boolean.

```jsx
const isFrog = enacts($Frog, character);
```

<br/>
<br/>

[[top]](https://github.com/ruby-cube/rue/tree/main/packages/planify#planify-#planify-)

¬© 2023 - present [Ruby Y Wang](https://github.com/ruby-cube)